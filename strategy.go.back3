package main

import (
	"Polybot/polymarket"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"math"
	"strconv"
	"sync"
	"time"
)

const Workers = 5

type Strategy struct {
	executor  *OrderExecutor
	markets   chan string
	pending   map[string]bool
	pendingMu *sync.Mutex
}

func NewStrategy(client *PolymarketClient) *Strategy {
	strategy := &Strategy{
		executor:  NewOrderExecutor(client),
		markets:   make(chan string, Workers),
		pending:   make(map[string]bool),
		pendingMu: &sync.Mutex{},
	}
	strategy.Run()
	return strategy
}

func (s *Strategy) OnUpdate(assetID []string) {
	s.enqueueMarketsFromAssets(assetID)
}

func (s *Strategy) Run() {
	for i := 0; i < Workers; i++ {
		go func() {
			for {
				market := <-s.markets
				s.handle(market)
				s.markDone(market)
			}
		}()
	}
}

func (s *Strategy) enqueueMarketsFromAssets(assetIDs []string) {
	if len(assetIDs) == 0 {
		return
	}
	marketsToCheck := make(map[string]bool)
	for _, id := range assetIDs {
		if marketID, ok := GetMarketIDByToken(id); ok {
			marketsToCheck[marketID] = true
		}
	}
	for marketID := range marketsToCheck {
		s.enqueueMarket(marketID)
	}
}

func (s *Strategy) enqueueMarket(marketID string) {
	s.pendingMu.Lock()
	if s.pending[marketID] {
		s.pendingMu.Unlock()
		return
	}
	s.pending[marketID] = true
	s.pendingMu.Unlock()
	s.markets <- marketID
}

func (s *Strategy) markDone(marketID string) {
	s.pendingMu.Lock()
	defer s.pendingMu.Unlock()
	delete(s.pending, marketID)
}

func (s *Strategy) saveSnapshot() {

}


func (s *Strategy) handle(marketID string) {
	if !IsActiveMarket(marketID) {
		return
	}

	marketInfo := GetMarketInfo(marketID)
	if marketInfo == nil {
		return
	}

	now := time.Now().Unix()
	passSeconds := marketInfo.EndDateTS - now
	elapsedSeconds := now - marketInfo.StartDateTS

	//if passSeconds <= 0 || elapsedSeconds <= MinimumStartWaitingSec {
	//	return
	//}

	if passSeconds <= 0 {
		return
	}

	upToken := marketInfo.ClobTokenIDs[0]
	downToken := marketInfo.ClobTokenIDs[1]

	upBestBidAsk := GetBestBidAsk(upToken)
	downBestBidAsk := GetBestBidAsk(downToken)

	if upBestBidAsk[0] == nil || upBestBidAsk[1] == nil || downBestBidAsk[0] == nil || downBestBidAsk[1] == nil {
		return
	}

	if _, ok := snapshot[marketID]; !ok {
		snapshot[marketID] = make(map[string]any)
	}

	marketSnapshot, ok := snapshot[marketID].(map[string]any)

	if !ok {
		marketSnapshot = make(map[string]any)
		snapshot[marketID] = marketSnapshot
	}

	marketSnapshot[strconv.FormatInt(now, 10)] = map[string]any{
		"up":   upBestBidAsk,
		"down": downBestBidAsk,
	}

	data, err := json.MarshalIndent(snapshot[marketID], "", "  ")
	if err != nil {
		log.Printf("failed to marshal snapshot: %v", err)
		return
	}

	filename := fmt.Sprintf("/Users/alimohammad/PycharmProjects/Scripts/data/snapshot_%s.json", marketID)
	if err := ioutil.WriteFile(filename, data, 0644); err != nil {
		log.Printf("failed to write snapshot file: %v", err)
	}

	return

	upQty, upAvg, _ := GetAssetPosition(upToken)
	downQty, downAvg, _ := GetAssetPosition(downToken)

	state := State{
		upQty:        upQty,
		downQty:      downQty,
		upAvgCents:   upAvg,
		downAvgCents: downAvg,
	}

	book := OrderBook{
		up: OrderBookSide{
			bestBid:     upBestBidAsk[0].Price,
			bestBidSize: upBestBidAsk[0].Size,
			bestAsk:     upBestBidAsk[1].Price,
			bestAskSize: upBestBidAsk[1].Size,
		},
		down: OrderBookSide{
			bestBid:     downBestBidAsk[0].Price,
			bestBidSize: downBestBidAsk[0].Size,
			bestAsk:     downBestBidAsk[1].Price,
			bestAskSize: downBestBidAsk[1].Size,
		},
	}

	openOrdersByTag := getOpenOrdersByTag(marketID)
	plan := TradingDecision(state, book, int(elapsedSeconds), openOrdersByTag, upToken, downToken)
	s.executePlan(marketID, upToken, downToken, plan)
}

type State struct {
	upQty        float64
	downQty      float64
	upAvgCents   float64
	downAvgCents float64
}

type OrderBookSide struct {
	bestBid     int
	bestBidSize float64
	bestAsk     int
	bestAskSize float64
}

type OrderBook struct {
	up   OrderBookSide
	down OrderBookSide
}

type OrderSide int

const (
	SideUp OrderSide = iota
	SideDown
)

type DesiredOrder struct {
	side  OrderSide
	price int
	size  float64
	tag   string
}

type Plan struct {
	cancelTags []string
	place      []DesiredOrder
}

type Phase int

const (
	PhaseEarly Phase = iota
	PhaseMiddle
	PhaseLate
)

const (
	minQty           = 5
	feesBuffer       = 1
	profitFloor      = 1
	deadband         = 10
	softImbalance    = 25
	hardImbalance    = 55
	maxImbalance     = 85
	closeOnlySeconds = 20
	bufferDefault    = 1
	bufferLate       = 0
	ladderLevels     = 4
	ladderStep       = 2
	baseQtyEarly     = 35
	baseQtyMid       = 30
	baseQtyLate      = 20
	certainPrice     = 94
	certainTimeLeft  = 60
	certainQtyPer    = 10
	certainMaxTotal  = 30
	loserPrice       = 8
	requoteDelta     = 2
)

type Params struct {
	phase          Phase
	edgeTarget     int
	maxLossPerPair float64
	imbMax         float64
	baseSize       float64
}

func GetParams(elapsedSeconds int) Params {
	switch {
	case elapsedSeconds < 300:
		return Params{
			phase:          PhaseEarly,
			edgeTarget:     2,
			maxLossPerPair: 2.0,
			imbMax:         8,
			baseSize:       15,
		}
	case elapsedSeconds < 600:
		return Params{
			phase:          PhaseMiddle,
			edgeTarget:     1,
			maxLossPerPair: 3.0,
			imbMax:         5,
			baseSize:       10,
		}
	default:
		return Params{
			phase:          PhaseLate,
			edgeTarget:     0,
			maxLossPerPair: 5.0,
			imbMax:         3,
			baseSize:       5,
		}
	}
}

func Urgency(elapsedSeconds int) float64 {
	if elapsedSeconds <= 600 {
		return 0
	}
	return clampFloat((float64(elapsedSeconds)-600.0)/300.0, 0, 1)
}

func ComputePairedBids(book OrderBook, edgeTarget int, imbalance, imbMax float64) (int, int) {
	maxUp := maxInt(1, book.up.bestAsk-TickCents)
	maxDown := maxInt(1, book.down.bestAsk-TickCents)

	bU := minInt(book.up.bestBid+TickCents, maxUp)
	bD := minInt(book.down.bestBid+TickCents, maxDown)

	skew := imbalance / math.Max(imbMax, 1.0)
	skew = clampFloat(skew, -1.0, 1.0)

	skewTicks := int(math.Round(3.0 * skew))

	bU -= skewTicks
	bD += skewTicks

	bU = clampInt(bU, 1, maxUp)
	bD = clampInt(bD, 1, maxDown)

	sumCap := PayoutCents - edgeTarget
	sum := bU + bD

	if sum > sumCap {
		excess := sum - sumCap
		dropU := (excess + 1) / 2
		dropD := excess / 2

		bU -= dropU
		bD -= dropD
	}

	bU = clampInt(bU, 1, maxUp)
	bD = clampInt(bD, 1, maxDown)

	if bU+bD >= PayoutCents {
		bU = maxInt(1, bU-TickCents)
		bD = maxInt(1, bD-TickCents)
	}

	return bU, bD
}

func MaxHedgePrice(deficitSide OrderSide, book OrderBook, edgeTarget int) int {
	if deficitSide == SideDown {
		refUp := minInt(book.up.bestBid+TickCents, maxInt(1, book.up.bestAsk-TickCents))
		maxP := PayoutCents - edgeTarget - refUp
		return clampInt(maxP, 1, book.down.bestAsk)
	}
	refDown := minInt(book.down.bestBid+TickCents, maxInt(1, book.down.bestAsk-TickCents))
	maxP := PayoutCents - edgeTarget - refDown
	return clampInt(maxP, 1, book.up.bestAsk)
}

func TradingDecision(state State, book OrderBook, elapsedSeconds int, openOrdersByTag map[string][]*Order, upToken, downToken string) Plan {
	timeLeft := TotalSeconds - elapsedSeconds
	if timeLeft <= 0 {
		cancelTags := make([]string, 0, len(openOrdersByTag))
		for tag := range openOrdersByTag {
			cancelTags = append(cancelTags, tag)
		}
		return Plan{cancelTags: cancelTags, place: nil}
	}

	pendingUp := pendingQtyForToken(openOrdersByTag, upToken)
	pendingDown := pendingQtyForToken(openOrdersByTag, downToken)
	imbalance := (state.upQty + pendingUp) - (state.downQty + pendingDown)

	bidUp, bidDown := calculateTargetBids(book, timeLeft, imbalance)
	bidUp, bidDown, disableUp, disableDown := applyInventoryControl(state, book, timeLeft, imbalance, bidUp, bidDown)

	qtyUp, qtyDown := calculateSizes(timeLeft, imbalance, disableUp, disableDown)

	desired := make([]DesiredOrder, 0, ladderLevels*2+2)
	desired = append(desired, buildLadder(SideUp, bidUp, qtyUp)...)
	desired = append(desired, buildLadder(SideDown, bidDown, qtyDown)...)
	desired = append(desired, buildCertaintyOrders(state, book, timeLeft, imbalance)...)

	return reconcileOrders(desired, openOrdersByTag)
}

func pendingQtyForToken(openOrdersByTag map[string][]*Order, tokenID string) float64 {
	total := 0.0
	for _, orders := range openOrdersByTag {
		for _, order := range orders {
			if order == nil || order.AssetID != tokenID {
				continue
			}
			remaining := order.OriginalSize - order.MatchedSize
			if remaining > 0 {
				total += remaining
			}
		}
	}
	return total
}

func calculateTargetBids(book OrderBook, timeLeft int, imbalance float64) (int, int) {
	askUp := book.up.bestAsk
	askDown := book.down.bestAsk
	if askUp <= 0 || askDown <= 0 {
		return 0, 0
	}

	bufferUp, bufferDown := calculateBuffers(timeLeft, imbalance)
	targetBidUp := PayoutCents - askDown - bufferUp
	targetBidDown := PayoutCents - askUp - bufferDown

	targetBidUp = clampInt(targetBidUp, 1, askUp-1)
	targetBidDown = clampInt(targetBidDown, 1, askDown-1)

	targetBidUp = maxInt(targetBidUp, book.up.bestBid)
	targetBidDown = maxInt(targetBidDown, book.down.bestBid)

	return targetBidUp, targetBidDown
}

func calculateBuffers(timeLeft int, imbalance float64) (int, int) {
	base := bufferDefault
	if timeLeft <= 120 {
		base = bufferLate
	}

	absImb := math.Abs(imbalance)
	if absImb <= deadband {
		return base, base
	}

	skew := 0
	if absImb > softImbalance {
		skew = 1
	}
	if absImb > hardImbalance {
		skew = 2
	}

	if imbalance > 0 {
		return minInt(3, base+skew), maxInt(0, base-skew)
	}
	return maxInt(0, base-skew), minInt(3, base+skew)
}

func maxPayToClose(sideToClose OrderSide, state State) int {
	if sideToClose == SideUp {
		if state.downQty <= 0 {
			return 0
		}
		avgDown := int(math.Round(state.downAvgCents))
		return clampInt(PayoutCents-avgDown-feesBuffer-profitFloor, 1, 99)
	}
	if state.upQty <= 0 {
		return 0
	}
	avgUp := int(math.Round(state.upAvgCents))
	return clampInt(PayoutCents-avgUp-feesBuffer-profitFloor, 1, 99)
}

func applyInventoryControl(state State, book OrderBook, timeLeft int, imbalance float64, bidUp, bidDown int) (int, int, bool, bool) {
	askUp := book.up.bestAsk
	askDown := book.down.bestAsk

	absImb := math.Abs(imbalance)
	disableUp := false
	disableDown := false

	if askUp <= loserPrice {
		disableUp = true
	}
	if askDown <= loserPrice {
		disableDown = true
	}

	if absImb >= maxImbalance {
		if imbalance > 0 {
			disableUp = true
			closeCap := maxPayToClose(SideDown, state)
			if closeCap > 0 {
				bidDown = minInt(askDown-1, maxInt(bidDown, closeCap))
			}
		} else {
			disableDown = true
			closeCap := maxPayToClose(SideUp, state)
			if closeCap > 0 {
				bidUp = minInt(askUp-1, maxInt(bidUp, closeCap))
			}
		}
	} else if absImb >= hardImbalance {
		if imbalance > 0 {
			disableUp = true
			closeCap := maxPayToClose(SideDown, state)
			if closeCap > 0 {
				bidDown = minInt(askDown-1, maxInt(bidDown, closeCap))
			}
		} else {
			disableDown = true
			closeCap := maxPayToClose(SideUp, state)
			if closeCap > 0 {
				bidUp = minInt(askUp-1, maxInt(bidUp, closeCap))
			}
		}
	} else if absImb >= softImbalance {
		if imbalance > 0 {
			closeCap := maxPayToClose(SideDown, state)
			if closeCap > 0 {
				bidDown = minInt(askDown-1, maxInt(bidDown, closeCap))
			}
		} else {
			closeCap := maxPayToClose(SideUp, state)
			if closeCap > 0 {
				bidUp = minInt(askUp-1, maxInt(bidUp, closeCap))
			}
		}
	}

	if timeLeft <= closeOnlySeconds {
		if imbalance > deadband {
			disableUp = true
		} else if imbalance < -deadband {
			disableDown = true
		}
	}

	if disableUp {
		bidUp = 0
	}
	if disableDown {
		bidDown = 0
	}

	return bidUp, bidDown, disableUp, disableDown
}

func calculateTotalQty(timeLeft int) int {
	if timeLeft > 600 {
		return baseQtyEarly
	}
	if timeLeft > 300 {
		return baseQtyMid
	}
	return baseQtyLate
}

func calculateSizes(timeLeft int, imbalance float64, disableUp, disableDown bool) (float64, float64) {
	baseQty := float64(calculateTotalQty(timeLeft))
	absImb := math.Abs(imbalance)

	multUp := 1.0
	multDown := 1.0
	if absImb <= deadband {
	} else if absImb <= softImbalance {
		if imbalance > 0 {
			multUp = 0.85
			multDown = 1.15
		} else {
			multUp = 1.15
			multDown = 0.85
		}
	} else {
		if imbalance > 0 {
			multUp = 0.70
			multDown = 1.30
		} else {
			multUp = 1.30
			multDown = 0.70
		}
	}

	qtyUp := math.Round(baseQty * multUp)
	qtyDown := math.Round(baseQty * multDown)

	if disableUp {
		qtyUp = 0
	}
	if disableDown {
		qtyDown = 0
	}

	return qtyUp, qtyDown
}

func buildLadder(side OrderSide, topBidPrice int, totalQty float64) []DesiredOrder {
	if topBidPrice <= 0 || totalQty < minQty {
		return nil
	}

	weights := []float64{0.35, 0.30, 0.20, 0.15}
	orders := make([]DesiredOrder, 0, ladderLevels)
	sideTag := "DOWN"
	if side == SideUp {
		sideTag = "UP"
	}

	for level := 0; level < ladderLevels; level++ {
		price := topBidPrice - (level * ladderStep)
		if price < 1 {
			continue
		}

		qty := math.Round(totalQty * weights[level])
		if qty < minQty {
			continue
		}

		orders = append(orders, DesiredOrder{
			side:  side,
			price: price,
			size:  qty,
			tag:   fmt.Sprintf("%s_L%d", sideTag, level),
		})
	}

	return orders
}

func buildCertaintyOrders(state State, book OrderBook, timeLeft int, imbalance float64) []DesiredOrder {
	if timeLeft > certainTimeLeft {
		return nil
	}

	askUp := book.up.bestAsk
	askDown := book.down.bestAsk
	if askUp <= 0 || askDown <= 0 {
		return nil
	}

	upCertain := askUp >= certainPrice
	downCertain := askDown >= certainPrice
	if upCertain && downCertain {
		return nil
	}
	if !upCertain && !downCertain {
		return nil
	}

	orders := make([]DesiredOrder, 0, 1)
	if upCertain {
		if state.upQty >= certainMaxTotal || imbalance >= hardImbalance {
			return nil
		}
		remainingCap := float64(certainMaxTotal) - state.upQty
		qty := math.Min(float64(certainQtyPer), remainingCap)
		if qty >= minQty {
			orders = append(orders, DesiredOrder{
				side:  SideUp,
				price: askUp - 1,
				size:  qty,
				tag:   "CERTAIN_UP",
			})
		}
	}

	if downCertain {
		if state.downQty >= certainMaxTotal || imbalance <= -hardImbalance {
			return orders
		}
		remainingCap := float64(certainMaxTotal) - state.downQty
		qty := math.Min(float64(certainQtyPer), remainingCap)
		if qty >= minQty {
			orders = append(orders, DesiredOrder{
				side:  SideDown,
				price: askDown - 1,
				size:  qty,
				tag:   "CERTAIN_DOWN",
			})
		}
	}

	return orders
}

func reconcileOrders(desired []DesiredOrder, openOrdersByTag map[string][]*Order) Plan {
	desiredByTag := make(map[string]DesiredOrder, len(desired))
	for _, d := range desired {
		desiredByTag[d.tag] = d
	}

	cancelSet := make(map[string]bool)
	for tag, orders := range openOrdersByTag {
		desiredOrder, ok := desiredByTag[tag]
		if !ok {
			cancelSet[tag] = true
			continue
		}
		if len(orders) != 1 {
			cancelSet[tag] = true
			continue
		}
		if !orderMatchesDesired(orders[0], desiredOrder) {
			cancelSet[tag] = true
		}
	}

	places := make([]DesiredOrder, 0, len(desired))
	for _, d := range desired {
		if d.price <= 0 || d.size < minQty {
			continue
		}
		existing := openOrdersByTag[d.tag]
		if len(existing) == 1 && orderMatchesDesired(existing[0], d) {
			continue
		}
		if len(existing) > 0 {
			cancelSet[d.tag] = true
		}
		places = append(places, d)
	}

	cancelTags := make([]string, 0, len(cancelSet))
	for tag := range cancelSet {
		cancelTags = append(cancelTags, tag)
	}

	return Plan{cancelTags: cancelTags, place: places}
}

func orderMatchesDesired(order *Order, desired DesiredOrder) bool {
	if order == nil {
		return false
	}
	if intAbs(order.Price-desired.price) >= requoteDelta {
		return false
	}
	remaining := order.OriginalSize - order.MatchedSize
	if remaining <= 0 {
		return false
	}
	if math.Abs(remaining-desired.size) < 0.5 {
		return true
	}
	if order.MatchedSize > 0 && remaining < desired.size {
		return true
	}
	return false
}

func (s *Strategy) executePlan(marketID, upToken, downToken string, plan Plan) {
	cancelTags := dedupeStrings(plan.cancelTags)
	for _, tag := range cancelTags {
		orderIDs := GetOrderIDsByMarket(marketID, tag)
		if len(orderIDs) == 0 {
			continue
		}
		if err := s.executor.CancelOrders(orderIDs, tag); err != nil {
			log.Printf("cancel order failed: market=%s tag=%s err=%v", marketID, tag, err)
		}
	}

	for _, order := range plan.place {
		tokenID := downToken
		if order.side == SideUp {
			tokenID = upToken
		}

		if order.price < 1 || order.price >= PayoutCents {
			continue
		}

		size := normalizeOrderSize(order.size)
		if size <= 0 {
			continue
		}

		s.placeLimitBuy(marketID, tokenID, order.price, size, order.tag)
	}
}

func getOpenOrdersByTag(marketID string) map[string][]*Order {
	ordersMu.RLock()
	defer ordersMu.RUnlock()

	set := MarketToOrderIDs[marketID]
	if len(set) == 0 {
		return map[string][]*Order{}
	}
	out := make(map[string][]*Order, len(set))
	for id := range set {
		order := Orders[id]
		if order == nil || order.Tag == "" {
			continue
		}
		out[order.Tag] = append(out[order.Tag], order)
	}
	return out
}

func normalizeOrderSize(size float64) float64 {
	if size <= 0 {
		return 0
	}
	return math.Max(size, PolymarketMinimumOrderSize)
}

func isOrderClose(order *Order, desired DesiredOrder) bool {
	if order == nil {
		return false
	}
	if intAbs(order.Price-desired.price) >= TickCents {
		return false
	}
	return math.Abs(order.OriginalSize-desired.size) < 0.5
}

func (s *Strategy) placeLimitBuy(marketID, tokenID string, price int, qty float64, tag string) string {
	if qty < PolymarketMinimumOrderSize {
		return ""
	}
	fPrice := float64(price) / 100.0

	orderID, err := s.executor.BuyLimit(tokenID, fPrice, qty, polymarket.OrderTypeGTC)
	if err != nil {
		log.Printf("place buy failed: market=%s token=%s price=%d qty=%.4f err=%v", marketID, tokenID, price, qty, err)
		return ""
	}

	AddOrder(&Order{
		ID:           orderID,
		MarketID:     marketID,
		AssetID:      tokenID,
		OriginalSize: qty,
		MatchedSize:  0,
		Price:        price,
		Tag:          tag,
	})
	return orderID
}
